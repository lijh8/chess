<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>中国象棋棋盘</title>
  <style>
    body { display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f0f0f0; }
    svg { cursor: pointer; }
  </style>
</head>
<body>
  <svg id="chessboard" xmlns="http://www.w3.org/2000/svg"></svg>

  <div class="instructions">
    <ul>
      <li> 鼠标左键单击棋子或交叉点，依次绘制路径</li>
      <li> 鼠标左键双击路径的起点，删除整条路径</li>
      <li> 鼠标左键双击无路径连接的棋子，删除棋子</li>
    </ul>
  </div>

  <script>
    const fontSize = 22;
    const cell = fontSize * 1.8;
    const margin = 30;
    const ox = margin, oy = margin;
    const w = 8 * cell, h = 9 * cell;
    const rad = fontSize * 0.65;

    const svg = document.getElementById('chessboard');
    svg.setAttribute('width', w + 2 * margin);
    svg.setAttribute('height', h + 2 * margin);

    // === 创建 svg 元素 ===
    const el = (tag, props, text = '') => {
      const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (let k in props) {
        e.setAttribute(k, props[k]);
      }
      if (text) e.textContent = text;
      return e;
    };

    // === 棋盘线 ===
    const gLines = el('g', { stroke: 'black' });
    for (let c = 0; c < 9; c++) gLines.appendChild(el('line', { x1: ox + c * cell, y1: oy, x2: ox + c * cell, y2: oy + h }));
    for (let r = 0; r < 10; r++) gLines.appendChild(el('line', { x1: ox, y1: oy + r * cell, x2: ox + w, y2: oy + r * cell }));
    const d = (x1, y1, x2, y2) => el('line', { x1: ox + x1 * cell, y1: oy + y1 * cell, x2: ox + x2 * cell, y2: oy + y2 * cell });
    gLines.append(d(3,0,5,2), d(5,0,3,2), d(3,7,5,9), d(5,7,3,9));
    svg.appendChild(gLines);

    // === 楚河汉界 ===
    svg.append(
      el('rect', { x: ox, y: oy + 4*cell + 1, width: w, height: cell - 2, fill: 'white' }),
      el('text', { x: ox + w/2, y: oy + 4*cell + cell/2, 'font-size': fontSize, 'text-anchor': 'middle', 'dominant-baseline': 'middle' }, '楚 河 汉 界')
    );

    // === 棋子数据 ===
    const piecesData = [
      ['1-1','车'],['2-1','马'],['3-1','象'],['4-1','士'],['5-1','将'],['6-1','士'],['7-1','象'],['8-1','马'],['9-1','车'],
      ['2-3','炮'],['8-3','炮'],
      ['1-4','卒'],['3-4','卒'],['5-4','卒'],['7-4','卒'],['9-4','卒'],
      ['1-10','车'],['2-10','马'],['3-10','相'],['4-10','仕'],['5-10','帅'],['6-10','仕'],['7-10','相'],['8-10','马'],['9-10','车'],
      ['2-8','炮'],['8-8','炮'],
      ['1-7','兵'],['3-7','兵'],['5-7','兵'],['7-7','兵'],['9-7','兵']
    ];

    const pieceGroups = new Map();
    const allPaths = [];
    let currentPath = null;

    // 获取网格位置对应的像素坐标
    const getPixelPos = (pos) => {
      const [c, r] = pos.split('-').map(Number);
      return { x: ox + (c - 1) * cell, y: oy + (r - 1) * cell };
    };

    // 创建棋子
    piecesData.forEach(([pos, char]) => {
      const { x, y } = getPixelPos(pos);
      const g = el('g', { 'data-pos': pos });
      g.append(
        el('circle', { cx: x, cy: y, r: rad, fill: 'white', stroke: 'black' }),
        el('text', { x, y, 'font-size': fontSize, 'text-anchor': 'middle', 'dominant-baseline': 'middle', fill: (pos.split('-')[1] >= 7 ? 'red' : 'black') }, char)
      );
      svg.appendChild(g);
      pieceGroups.set(pos, g);
    });

    // 获取点击命中的网格点（在 rad 范围内）
    function getGridPos(clientX, clientY) {
      const rect = svg.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      for (let c = 1; c <= 9; c++) {
        for (let r = 1; r <= 10; r++) {
          const gx = ox + (c - 1) * cell;
          const gy = oy + (r - 1) * cell;
          const dx = x - gx;
          const dy = y - gy;
          if (dx * dx + dy * dy <= rad * rad) {
            return `${c}-${r}`;
          }
        }
      }
      return null;
    }

    // 判断某位置是否被任何路径使用（作为起点或终点）
    function isConnected(pos) {
      return allPaths.some(path => path.points.includes(pos) && path.lines.length > 0);
    }

    function drawSegment(fromPos, toPos) {
      const start = getPixelPos(fromPos);
      const end = getPixelPos(toPos);

      let sx = start.x, sy = start.y;
      let ex = end.x, ey = end.y;

      const dx = ex - sx;
      const dy = ey - sy;
      const len = Math.hypot(dx, dy);

      // 如果长度为0，不画线
      if (len === 0) return null;

      // 起点有棋子：从 circle 边缘开始
      if (pieceGroups.has(fromPos) && len > rad) {
        const ratioStart = rad / len;
        sx += dx * ratioStart;
        sy += dy * ratioStart;
      }

      // 终点有棋子：在 circle 边缘结束
      if (pieceGroups.has(toPos) && len > rad) {
        const ratioEnd = (len - rad) / len;
        ex = start.x + dx * ratioEnd;
        ey = start.y + dy * ratioEnd;
      }

      const line = el('line', {
        x1: sx, y1: sy, x2: ex, y2: ey,
        stroke: 'blue', 'stroke-width': '2', 'stroke-dasharray': '5,5', 'data-from': fromPos, 'data-to': toPos
      });
      svg.appendChild(line);
      return line;
    }

    function removePath(path) {
      path.lines.forEach(line => line.remove());
      const idx = allPaths.indexOf(path);
      if (idx !== -1) allPaths.splice(idx, 1);
    }

    // === 事件处理 ===
    svg.addEventListener('click', (e) => {
      const pos = getGridPos(e.clientX, e.clientY);
      if (!pos) return;

      if (!currentPath) {
        currentPath = { points: [pos], lines: [] };
        allPaths.push(currentPath);
      } else {
        const last = currentPath.points[currentPath.points.length - 1];
        if (last !== pos) {
          const line = drawSegment(last, pos);
          if (line) {
            currentPath.points.push(pos);
            currentPath.lines.push(line);
          }
        }
      }
    });

    svg.addEventListener('dblclick', (e) => {
      const pos = getGridPos(e.clientX, e.clientY);
      if (!pos) return;

      // 双击起点：移除以其为起点的路径
      for (let i = allPaths.length - 1; i >= 0; i--) {
        const path = allPaths[i];
        if (path.points[0] === pos && path.lines.length > 0) {
          removePath(path);
          if (currentPath === path) currentPath = null;
          return;
        }
      }

      // 双击无连接的棋子：移除棋子
      const piece = pieceGroups.get(pos);
      if (piece && !isConnected(pos)) {
        piece.remove();
        pieceGroups.delete(pos);
        if (currentPath && currentPath.points[currentPath.points.length - 1] === pos) {
          currentPath = null;
        }
      }
    });
  </script>
</body>
</html>
